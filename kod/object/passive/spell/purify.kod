% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% All rights reserved.
%
% This software is distributed under a license that is described in
% the LICENSE file that accompanies it.
%
% Meridian is a registered trademark.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Purify is Spell

constants:

   include blakston.khd

   % At least how many enchantments should there be on a person to check for auto-remove?
   MIN_ENCHANTMENTS_FOR_AUTOREMOVE = 2

   % What's the minimum chance to remove spells we want before checking for auto-remove?
   MIN_CHANCE_FOR_AUTOREMOVE = 60

resources:

   purify_name_rsc = "purify"
   purify_icon_rsc = ipurify.bgf
   purify_desc_rsc = \
      "Removes harmful personal enchantments on the target. "
      "Requires emeralds and elderberries to cast."
   
   purify_on = "A bright, holy light is trying to cleanse your soul of impure effects."
   purify_not_enchanted = "%s%s is not affected by any negative magical energies."
   purify_spell_intro = "Shal'ille Lv. 4: Removes harmful personal enchantments on the target."
   purify_spell_self_cast_rsc = "You may only cast %s on yourself."

classvars:

   vrName = purify_name_rsc
   vrIcon = purify_icon_rsc
   vrDesc = purify_desc_rsc

   vrSpell_intro = purify_spell_intro

   viSpell_num = SID_PURIFY
   viSchool = SS_SHALILLE
   viSpell_level = 4
   viMana = 10
   viChance_To_Increase = 10
   
   viFlash = FLASH_GOOD   

properties:

   pbCan_cast_on_others = FALSE

messages:

   ResetReagents()
   {
      plReagents = $;
      plReagents = Cons([&Emerald,2],plReagents);
      plReagents = Cons([&Elderberry,2],plReagents);

      return;
   }

   GetNumSpellTargets()
   {
      if pbCan_cast_on_others
      {
         return 1;
      }

      % Can only cast on self, no need to target
      return 0;
   }

   CanPayCosts(who = $, lTargets = $, bItemCast = FALSE)
   {
      local target, i, lEnchantment, bHasEnchantment, oSpell;

      % If it's only self cast, spoof self as target for following code
      if NOT pbCan_Cast_on_others
      {
         lTargets = Cons(who, lTargets);
      }
      
      % Can cast spell if the 1 target item is a user
      if Length(lTargets) <> 1
      {
         return FALSE;
      }  

      target = First(lTargets);

      if not IsClass(target, &User)
      {
         if not bItemCast
         {
            Send(who,@MsgSendUser,#message_rsc=spell_bad_target, 
                 #parm1=vrName,#parm2=Send(target,@GetDef),#parm3=Send(target,@GetName));
         }
         
         return FALSE;
      }

      % The target must have an enchantment
      lEnchantment = send(target,@GetEnchantmentList);
      bHasEnchantment = IsClass(who,&DM);

      if lEnchantment <> $
      {
         for i in lEnchantment
         {
            oSpell = Nth(i,2);
            if Send(oSpell,@IsPersonalEnchantment)
               AND send(oSpell,@CanBeRemovedByPlayer)
               AND send(oSpell,@IsHarmful)
            {
               bHasEnchantment = TRUE;
               
               break;
            }
         }
      }
		
      if Send(target,@GetDamageOverTime) <> $
      {
         bHasEnchantment = TRUE;
      }

      if NOT bHasEnchantment
      {
         Send(who,@MsgSendUser,#message_rsc=purify_not_enchanted, 
              #parm1=Send(target,@GetDef),#parm2=Send(target,@GetName));
              
         return FALSE;
      }

      % Can only cast purify on yourself, to curb massive mule abuse.
      if NOT pbCan_cast_on_others AND target <> who
      {
         Send(who,@WaveSendUser,#wave_rsc=spell_fail_wav);
         Send(who,@MsgSendUser,#message_rsc=purify_spell_self_cast_rsc,#parm1=vrName);
      	return FALSE;
      }

      propagate;   
   }

   CastSpell(who = $, lTargets = $, iSpellPower = 0)
   {
      local oTarget, lInfo, oSpell, lList, lEnchantmentList;

      % If it's only self cast, spoof self as target for following code
      if NOT pbCan_Cast_on_others
      {
         lTargets = Cons(who, lTargets);
      }
      
      oTarget = First(lTargets);
      if oTarget <> who
      {
         Send(who,@MsgSendUser,#message_rsc=spell_cast_on_target,
              #parm1=Send(self,@GetName),#parm2=Send(oTarget,@GetDef),
              #parm3=Send(oTarget,@GetName));
      }
      
      Send(oTarget,@MsgSendUser,#message_rsc=purify_on);

      % keep tabs on guides/bards, but not admins.
      if IsClass(who, &DM)
      {
         if GetClass(who) = &DM
            AND who <> oTarget
         {
            debug(send(who,@GetTrueName)," cast purify on ",send(oTarget,@GetName));
         }

         if send(who,@PlayerIsImmortal)
         {
            % If they're immortal, let them clear everything.
            iSpellPower = $;
         }
      }

      send(self,@DoPurify,#who=oTarget,#spellpower=iSpellPower);

      propagate;
   }

   DoPurify(who=$, spellpower=$)
   "If DM cast, removes all Debuffs. If player cast, removes up to 50 points from the debuff's SP and duration, or 5 damage per tick from a DoT."
   {
		local i, iAmount, lEnchantments, oTimer, iTime, oSpell, iState, iNewState, bRemovedSomething, lEffect;

      		if who = $
      {
         return FALSE;
      }
		
		bRemovedSomething = FALSE;

      lEnchantments = send(who,@GetEnchantmentList);

      % Chance of $ means that we want to remove it all.
      if spellpower = $
      {

			for i in lEnchantments
			{
				oSpell = Nth(i,2);
				
				if Send(oSpell,@CanBeRemovedByPlayer) AND Send(oSpell,@IsHarmful)
				{
					Send(who,@RemoveEnchantment,#what=oSpell,#report=TRUE);
					bRemovedSomething = TRUE;
				}
			}
		
			for i in Send(who,@GetDamageOverTime)
			{
				send(who,@DeleteDamageOverTime,#what=First(i));
				bRemovedSomething = TRUE;
			}
			
         return bRemovedSomething;
      }

		for i in lEnchantments
		{
			oSpell = Nth(i,2);

			if Send(oSpell,@CanBeRemovedByPlayer) AND Send(oSpell,@IsHarmful)
			{				
				% Get the current state of the enchantment.
				oTimer = Nth(i,1);
				iTime = GetTimeRemaining(oTimer);
				iState = Nth(i,3);
				
				% Calculate the new state and time of the enchantment.
				iNewState = iState - spellpower;
				iTime = iTime * iNewState / iState;
				
				% Start the new enchantment with the time left and the new state,
				% but only if iNewState is greater than 0.
				if iNewState > 0
				{
					% Remove the current enchantment, but don't report.
					Send(who,@RemoveEnchantment,#what=oSpell,#report=FALSE);
					% Extra effects like added stat points are handled in GetStateValue, so we have to call it here.
					Send(oSpell,@GetStateValue,#who=who,#iSpellPower=iNewState,#target=who);
					Send(who,@StartEnchantment,#what=oSpell,#state=iNewState,#time=iTime,#lastcall=send(oSpell,@GetLastCall),#addicon=send(oSpell,@GetAddicon));
				}
				else
				{
					% Remove the current enchantment and report.
					Send(who,@RemoveEnchantment,#what=oSpell,#report=TRUE);
					bRemovedSomething = TRUE;
				}
			}
		}
		
		for i in Send(who,@GetDamageOverTime)
		{
			iState = Nth(i,7);
			iNewState = bound(Nth(i,7) - spellpower,0,$);
			iAmount = Nth(i,2)*iNewState/iState;
			
			% This is the portion of the DoT that we have removed. We pass that on to DoTWearingOff.
			lEffect = [First(i),iAmount,Nth(i,3),GetTickCount()-Nth(i,3),Nth(i,5),Nth(i,6),spellpower];
			
			Send(who,@SetOverTimeEffect,#i=i,#amount=iAmount,#state=iNewState);

			oSpell = First(i);
			
			if oSpell <> $
			{
				if iAmount > 0
				{
					% The spell hasn't been entirely removed. Let's feed the DoTWearingOff message the portion of the dot
					% that has been removed.
					send(oSpell,@DoTWearingOff,#who=who,#overtimeeffect=lEffect,#report=FALSE,#delayed=FALSE);
					send(who,@MsgSendUser,#message_rsc=curepoison_abates,#parm1=Send(oSpell,@GetName));
				}
				else
				{
					send(who,@MsgSendUser,#message_rsc=curepoison_removed,#parm1=Send(oSpell,@GetName));
				}
			}
		}
		
		send(who,@RemoveDamageOverTime);
      
      return bRemovedSomething;
   }
   
   GetPotionClass()
   {
      return &PurifyPotion;
   }


end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
