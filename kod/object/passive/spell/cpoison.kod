% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% All rights reserved.
%
% This software is distributed under a license that is described in
% the LICENSE file that accompanies it.
%
% Meridian is a registered trademark.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
CurePoison is Spell

constants:

   include blakston.khd

resources:

   curepoison_name_rsc = "remove corruption"
   curepoison_icon_rsc = icurpoi.bgf
   curepoison_desc_rsc = \
      "Pure, healing energy fights the effects of lingering corruption in the target.  "
	   "Requires herbs and elderberries to cast."
   
   curepoison_on = "The power of Shal'ille tries to purge the corruption from within you."

   curepoison_unnecessary = "%s%s does not seem to be suffering from the effects of corruption."
   curepoison_abates = "The effects of the %s are fading."
   curepoison_removed = "The effects of the %s no longer plague you!"

   curepoison_spell_intro = "Shal'ille Lv. 2: Pure, healing energy fights the effects of lingering corruption in the target."
	
classvars:

   vrName = curepoison_name_rsc
   vrIcon = curepoison_icon_rsc
   vrDesc = curepoison_desc_rsc

   vrSpell_intro = curepoison_spell_intro
   viSpell_num = SID_CURE_POISON
   viSchool = SS_SHALILLE
   viSpell_level = 2
   viMana = 10

   viChance_To_Increase = 30

   viFlash = FLASH_GOOD_SELF

properties:

messages:

   ResetReagents()
   {
      plReagents = $;
      plReagents = Cons([&Herbs,2],plReagents);
      plReagents = Cons([&Elderberry,1],plReagents);

      return;
   }

   GetNumSpellTargets()
   {
      return 1;
   }

   CanPayCosts(who = $, lTargets = $)
   {
      local target, i;
      
      % Can cast spell if the 1 target item is a user
      if Length(lTargets) <> 1
      {
	      return False;
      }

      target = First(lTargets);
      if not IsClass(target, &User)
      {
	      Send(who,@MsgSendUser,#message_rsc=spell_bad_target,#parm1=vrName,
	      #parm2=Send(target,@GetDef),#parm3=Send(target,@GetName));
	      return False;
      }

      %% make sure target is indeed poisoned
      if Send(target,@GetDamageOverTime) = $
      {
	      Send(who, @MsgSendUser, #message_rsc=curepoison_unnecessary,
           #parm1=Send(target,@GetCapDef),#parm2=Send(target,@GetName)); 
	      return False;
      }

      propagate;   % Check other things higher up
   }

   CastSpell(who = $, lTargets = $, iSpellpower = $)
   {
      local i, iState, iNewState, oTarget, iAmount, oSpell, lEffect;
      
      oTarget = First(lTargets);
      
      Send(oTarget,@MsgSendUser,#message_rsc=curepoison_on);
      Send(who,@MsgSendUser,#message_rsc=spell_cast_on_target,
	        #parm1=Send(self,@GetName),#parm2=Send(oTarget,@GetDef),
	        #parm3=Send(oTarget,@GetName));
	        
		for i in Send(who,@GetDamageOverTime)
		{
			iState = Nth(i,7);
			iNewState = bound(Nth(i,7) - iSpellpower,0,$);
			iAmount = Nth(i,2)*iNewState/iState;
			
			% This is the portion of the DoT that we have removed. We pass that on to DoTWearingOff.
			lEffect = [First(i),iAmount,Nth(i,3),GetTickCount()-Nth(i,3),Nth(i,5),Nth(i,6),Nth(i,7)];
			
			Send(who,@SetOverTimeEffect,#i=i,#amount=iAmount,#state=iNewState);

			oSpell = First(i);
			
			if oSpell <> $
			{
				if iAmount > 0
				{
					% The spell hasn't been entirely removed. Let's feed the DoTWearingOff message the portion of the dot
					% that has been removed.
					send(oSpell,@DoTWearingOff,#who=who,#overtimeeffect=lEffect,#report=FALSE,#delayed=FALSE);
					send(who,@MsgSendUser,#message_rsc=curepoison_abates,#parm1=Send(oSpell,@GetName));
				}
				else
				{
					send(who,@MsgSendUser,#message_rsc=curepoison_removed,#parm1=Send(oSpell,@GetName));
				}
			}
		}

		send(who,@RemoveDamageOverTime);
      
      propagate;
   } 

   GetPotionClass()
   {
      RETURN &CurePoisonPotion;
   }

end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
