% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% All rights reserved.
%
% This software is distributed under a license that is described in
% the LICENSE file that accompanies it.
%
% Meridian is a registered trademark.

% IMPORTANT NOTE: If you change the spell purge you might destroy the LogSafePenaltyEnable-function

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Purge is Spell

constants:

   include blakston.khd

resources:

   Purge_name_rsc = "purge"
   Purge_icon_rsc = ipurge.bgf
   Purge_desc_rsc = \
      "Strips helpful personal enchantments off of the target. "
      "Requires emeralds and purple mushrooms to cast."
   
   Purge_on = \
      "A bright, holy light is trying to burn away your beneficial "
      "enchantments."
   Purge_not_enchanted = "%s%s is not affected by any helpful magical "
      "energies."
   Purge_spell_intro = \
      "Shal'ille Lv. 5: Removes helpful personal enchantments on the target."

classvars:

   vrName = Purge_name_rsc
   vrIcon = Purge_icon_rsc
   vrDesc = Purge_desc_rsc

   viSpell_num = SID_PURGE
   viSchool = SS_SHALILLE
   viSpell_level = 5
   viMana = 20
   viSpellExertion = 10
   viChance_To_Increase = 10

   viHarmful = TRUE
   viOutlaw = TRUE
   viNoNewbieOffense = TRUE

   viFlash = FLASH_BAD   

properties:

messages:

   ResetReagents()
   {
      plReagents = $;
      plReagents = Cons([&Emerald,5],plReagents);
      plReagents = Cons([&PurpleMushroom,2],plReagents);

      return;
   }

   GetNumSpellTargets()
   {
      return 1;
   }

   CanPayCosts(who = $, lTargets = $, bItemCast = FALSE)
   {
      local target, i, lEnchantment, bHasEnchantment, oSpell;
      
      % Can cast spell if the 1 target item is a user
      if Length(lTargets) <> 1
      {
         return FALSE;
      }  

      target = First(lTargets);

      if NOT IsClass(target,&User)
      {
         if not bItemCast
         {
            Send(who,@MsgSendUser,#message_rsc=spell_bad_target, 
                 #parm1=vrName,#parm2=Send(target,@GetDef),
                 #parm3=Send(target,@GetName));
         }
         
         return FALSE;
      }

      % The target must have an enchantment or heal over time.
      lEnchantment = Send(target,@GetEnchantmentList);
      bHasEnchantment = IsClass(who,&DM);

      if lEnchantment <> $
      {
         for i in lEnchantment
         {
            oSpell = Nth(i,2);
            if Send(oSpell,@IsPersonalEnchantment)
               AND Send(oSpell,@CanBeRemovedByPlayer)
               AND NOT Send(oSpell,@IsHarmful)
            {
               bHasEnchantment = TRUE;
               
               break;
            }
         }
      }
		
      if Send(target,@GetHealOverTime) <> $
      {
         bHasEnchantment = TRUE;
      }

      if NOT bHasEnchantment
      {
         Send(who,@MsgSendUser,#message_rsc=Purge_not_enchanted, 
              #parm1=Send(target,@GetDef),#parm2=Send(target,@GetName));
              
         return FALSE;
      }

      propagate;
   }

   CastSpell(who = $, lTargets = $, iSpellPower = 0)
   {
      local oTarget, lInfo, oSpell, lList, lEnchantmentList;
      
      oTarget = First(lTargets);
      if oTarget <> who
      {
         Send(who,@MsgSendUser,#message_rsc=spell_cast_on_target,
              #parm1=Send(self,@GetName),#parm2=Send(oTarget,@GetDef),
              #parm3=Send(oTarget,@GetName));
      }
      
      Send(oTarget,@MsgSendUser,#message_rsc=Purge_on);

      % keep tabs on guides/bards, but not admins.
      if IsClass(who, &DM)
      {
         if GetClass(who) = &DM
            AND who <> oTarget
         {
            debug(Send(who,@GetTrueName)," cast Purge on ",Send(oTarget,@GetName));
         }

         if Send(who,@PlayerIsImmortal)
         {
            % If they're immortal, let them clear everything.
            iSpellPower = $;
         }
      }

      Send(self,@DoPurge,#who=oTarget,#spellpower=iSpellPower);

      propagate;
   }

   % Override this to allow for non-outlaw self-casting of spell on Sacred Haven.
   GetAttackTargets(who=$, lTargets=$, report=TRUE)
   "Returns a list of targets the caster can attack."
   {
      % If we're on Sacred Haven and we target ourselves, go for it.
      if NOT Send(SYS,@IsPKAllowed)
         AND lTargets <> $ AND First(lTargets) = who
      {
         return [who];
      }

      propagate;
   }

   DoPurge(who=$, spellpower=$)
   "Remove positive enchantments on who with a given chance to remove each one."
   {
		local i, iAmount, iState, iNewState, lEnchantments, oTimer, iTime, oSpell, bRemovedSomething;
		
      % Can't do this to nobody or to non-players.
      if who = $ OR NOT IsClass(who,&Player)
      {
         return FALSE;
      }

		bRemovedSomething = FALSE;
		
      % A spellpower of $ means that we want to remove it all.
      if spellpower = $
      {
         Send(who,@RemoveAllPersonalEnchantments);
			
			for i in Send(who,@GetHealOverTime)
			{
				send(who,@DeleteHealOverTime,#what=First(i));
			}
			
			bRemovedSomething = TRUE;
         
         return TRUE;
      }
		
		lEnchantments = Send(who,@GetEnchantmentList);
		
		for i in lEnchantments
		{
			oSpell = Nth(i,2);

			if Send(oSpell,@IsPersonalEnchantment)
				AND Send(oSpell,@CanBeRemovedByPlayer)
				AND NOT Send(oSpell,@IsHarmful)
			{				
				% Get the current state of the enchantment.
				oTimer = Nth(i,1);
				iTime = GetTimeRemaining(oTimer);
				iState = Nth(i,3);
				
				% Calculate the new state and time of the enchantment.
				iNewState = iState - spellpower / (2 * Send(oSpell,@GetPurgeFactor));
				iTime = iTime * iNewState / iState;
				
				% Start the new enchantment with the time left and the new state,
				% but only if iNewState is greater than 0.
				if iNewState > 0
				{
					% Remove the current enchantment, but don't report.
					Send(who,@RemoveEnchantment,#what=oSpell,#report=FALSE);
					% Extra effects like added stat points are handled in GetStateValue, so we have to call it here.
					Send(oSpell,@GetStateValue,#who=who,#iSpellPower=iNewState,#target=who);
					Send(who,@StartEnchantment,#what=oSpell,#state=iNewState,#time=iTime,#lastcall=send(oSpell,@GetLastCall),#addicon=send(oSpell,@GetAddicon));
				}
				else
				{
					% Remove the current enchantment and report.
					Send(who,@RemoveEnchantment,#what=oSpell,#report=TRUE);
					bRemovedSomething = TRUE;
				}
			}
		}
		
		for i in Send(who,@GetHealOverTime)
		{
			iState = Nth(i,7);
			iNewState = bound(Nth(i,7) - spellpower/2,0,$);
			iAmount = Nth(i,2)*iNewState/iState;
			Send(who,@SetOverTimeEffect,#i=i,#amount=iAmount,#state=iNewState);

			if iAmount = 0
			{
				bRemovedSomething = TRUE;
			}
		}
		
		send(who,@RemoveHealOverTime);

      return bRemovedSomething;
   }

end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
