% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% All rights reserved.
%
% This software is distributed under a license that is described in
% the LICENSE file that accompanies it.
%
% Meridian is a registered trademark.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
AttackSpell is Spell

% Generic attacking spell, such as blast or bolt spells.

constants:

   include blakston.khd

resources:

   attack_spell_hit_rsc = "You hit %s%s."
   attack_spell_no_self_rsc = "You can't cast %s on yourself."
   attack_spell_out_of_range = "Your %s does not have enough range to cause %s%s any harm."

classvars:

   viAttack_type = 0
   viAttack_spell = ATCK_SPELL_ALL

   viCast_delay = 2000
	viCast_time = 1000
	viDamage = 10
   viRange = $
	

   viHarmful = TRUE
   viOutlaw = TRUE

	% Chance to increase is one in viChance_To_Increase.
   viChance_To_Increase = 20

   vbIsRangedAttack = FALSE

properties:

   pbAbsolute = FALSE

messages:

   GetNumSpellTargets()
   {
      return 1;
   }

	GetDamage(who=$,target=$,iSpellPower=0,bItemCast=FALSE)
	{
		local iDamage, iManaFocus;
		
      iDamage = viDamage*100;

      if IsClass(who,&Player)
      {
         Send(who,@SetKillTarget,#target=target);
         Send(who,@SetPlayerFlag,#flag=PFLAG_DID_DAMAGE,#value=TRUE);

         if NOT bItemCast
         {
            % Do the sound, and the third person animation.
            piCast_successes = piCast_successes + 1 ;
            Send(who,@DoCast);      %% window overlay

            % Scale damage with the spell's spellpower.
            iDamage = iDamage * iSpellPower / 100;

            if Send(who,@CheckPlayerFlag,#flag=PFLAG_MANA_FOCUS) and viSchool = SS_FAREN
            {
               % Scale damage with mana focus' spellpower if we have it up and if we are casting a Faren spell.
               iManaFocus = First(Send(who,@GetEnchantedState,#what=Send(SYS,@FindSpellByNum,#num=SID_MANA_FOCUS))) + 1;
               iDamage = iDamage + iDamage * iManaFocus / 100;
            }
         }
      }
		
		return iDamage;
	}
	
   CastSpell(who = $, lTargets = $, iSpellPower = 0, bItemCast = FALSE)
   {
      local iDamage, iTotalRange, oRoom, oTarget;
		
      oTarget = First(lTargets);
      oRoom = Send(who,@GetOwner);
		
      Send(oRoom,@SomethingWaveRoom,#what=who,#wave_rsc=Send(self,@GetSpellSound));
      Send(oRoom,@SpellCast,#who=who,#oSpell=self,#lItems=lTargets);
      Send(self,@CreateProjectile,#who=who,#victim=oTarget);
		
		% Finally, let's check if we are still in range of our target at this point. If not,
		% our spell fails with full cost.
      if viRange <> $
      {
         iTotalRange = viRange;

         % A little fudge factor to account for lag drift, etc.
         if IsClass(oTarget,&Player) AND Send(oTarget,@HasMovedRecently)
         {
            iTotalRange = iTotalRange + RANGE_MOVEMENT_BONUS;
         }

         if Send(who,@SquaredDistanceTo,#what=oTarget) > (iTotalRange * iTotalRange)
         {
            if NOT bItemCast
            {
               Send(who,@MsgSendUser,#message_rsc=attack_spell_out_of_range,#parm1=vrName,#parm2=Send(oTarget,@GetDef),#parm3=Send(oTarget,@GetName));
            }

            return;
         }
      }
		
		iDamage = send(self,@GetDamage,#who=who,#target=oTarget,#iSpellPower=iSpellPower,#bItemCast=bItemCast);
     
      % After figuring damage, do an AssessDamage.  This will handle the necessary attack messages.
      iDamage = Send(oTarget,@AssessDamage,#what=who,#damage=iDamage,#atype=viAttack_type,#aspell=Send(self,@GetAttackSpell),#absolute=pbAbsolute);

      Send(who,@AssessHit,#what=oTarget,#damage=iDamage,#use_weapon=self,#stroke_obj=self,#improve=FALSE);

      if iDamage = $
      {
         Send(who,@KilledSomething,#what=oTarget,#use_weapon=self);
      } 

      Send(oRoom,@SomethingAttacked,#what=who,#victim=oTarget,#use_weapon=self);

      Send(self,@DoSideEffect,#who=who,#victim=oTarget,#damage=iDamage);
		
      if not bItemCast
      {
         Send(self,@ImproveAbility,#who=who,#target=oTarget);
      }

      return;
   }

   GetAttackSpell()
   {
      return viAttack_spell;
   }

   GetAttackType()
   {
      return viAttack_type;
   }

   IsRangedAttack()
   {
      return vbIsRangedAttack;
   }

   % This is for the attack message infrastructure.
   GetAttackName()
   {
      return vrName;
   }
	
   % The chance to do something in addition to normal damage.
   DoSideEffect(who=$,victim=$,damage=0)
   {
      return;
   }

   % Add a pretty projectile.
   CreateProjectile(who=$,victim=$)
   {
      return;
   }

end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
