% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% All rights reserved.
%
% This software is distributed under a license that is described in
% the LICENSE file that accompanies it.
%
% Meridian is a registered trademark.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Battler is NoMoveOn

constants:

   include blakston.khd

   % Raise or lower this number to raise or lower the chance the 'avoids 
   %  your attack' message comes up.
   BATTLER_AVOID_CHANCE = 50  

   % Threshold for the "wound" and "damage" levels of feedback.
   DAMAGE_THRESHOLD_WOUND = 500
   DAMAGE_THRESHOLD_DAMAGE = 1500

resources:

   % KNOWN BUG: placing a comment on the same line as a resource definition
   %  will comment out the next line.

   % battler_attacker_hit - You slash at Psychochild with your scimitar, cutting him for (10) damage.
   % battler_attacker_slay - You slash at Psychochild with your scimitar, cleaving him.
   % battler_attacker_miss - Your slash is blocked by Psychochild.
   % battler_attacker_fail - You slash at Psychochild with your scimitar, but fail to cause any real harm.
   % battler_defender_hit - Psychochild slashes at you with his scimitar, cutting you for (10) damage.
   % battler_defender_slay - Psychochild slashes at you with his scimitar, cleaving you.
   % battler_defender_miss - Psychochild's slash is blocked by you.
   % battler_defender_fail - Psychochild slashes at you with his scimitar, but fails to cause any real harm.

   battler_attacker_hit_blue = "~bYou %s %s%s with your %s, %s %s for ~k~B%q~B%q~b damage."
   battler_attacker_slay_blue = "~bYou %s %s%s with your %s, %s %s."
   battler_attacker_miss_blue = "~bYour %s %s %s%s."
   battler_attacker_fail_blue = "~bYou %s %s%s with your %s, but fail to cause any real harm."
   battler_defender_hit_blue = "~b%s%s %s you with %s %s, %s you for ~r~B%q~B%q~b damage."
   battler_defender_slay_blue = "~b%s%s %s you with %s %s, %s you."
   battler_defender_miss_blue = "~b%s%s's %s %s you."
   battler_defender_fail_blue = "~b%s%s %s you with %s %s, but fails to cause any real harm."

   battler_attacker_hit_plain = "~nYou %s %s%s with your %s, %s %s for ~k~B%q~B%q~n damage."
   battler_attacker_slay_plain = "~nYou %s %s%s with your %s, %s %s."
   battler_attacker_miss_plain = "~nYour %s %s %s%s."
   battler_attacker_fail_plain = "~nYou %s %s%s with your %s, but fail to cause any real harm."
   battler_defender_hit_plain = "~n%s%s %s you with %s %s, %s you for ~r~B%q~B%q~n damage."
   battler_defender_slay_plain = "~n%s%s %s you with %s %s, %s you."
   battler_defender_miss_plain = "~n%s%s's %s %s you."
   battler_defender_fail_plain = "~n%s%s %s you with %s %s, but fails to cause any real harm."

   battler_no_stroke_first = "hit"
   battler_no_stroke_third = "hits"

   battler_punch = "punch"
   battler_attack = "attack"
   battler_blocked  = "is blocked by" 
   battler_dodged  = "is dodged by"
   battler_parried  = "is parried by"
   battler_misses = "misses"

   battler_nick = "nicking"
   battler_wound = "wounding"
   battler_damage = "damaging"
   battler_slay = "slaying"

   battler_acid_nick = "burning"
   battler_acid_wound = "searing"
   battler_acid_damage = "disfiguring"
   battler_acid_slay = "dissolving"

   battler_fire_nick = "singing"
   battler_fire_wound = "charring"
   battler_fire_damage = "scorching"
   battler_fire_slay = "incinerating"

   battler_shock_nick =  "jolting"
   battler_shock_wound = "shocking"
   battler_shock_damage = "frying"
   battler_shock_slay = "electrocuting"

   battler_cold_nick = "cooling"
   battler_cold_wound = "chilling"
   battler_cold_damage = "frosting"
   battler_cold_slay = "freezing"

   battler_holy_nick = "infusing"
   battler_holy_wound = "cleansing"
   battler_holy_damage = "exorcising"
   battler_holy_slay = "purifying"

   battler_unholy_nick = "maligning"
   battler_unholy_wound = "polluting"
   battler_unholy_damage = "appalling"
   battler_unholy_slay = "corrupting"

   battler_quake_nick = "shaking"
   battler_quake_wound = "buffeting"
   battler_quake_damage = "slamming"
   battler_quake_slay = "flattening"

   battler_bite_nick = "gnawing"
   battler_bite_wound = "biting"
   battler_bite_damage = "tearing into"
   battler_bite_slay = "devouring"

   battler_claw_nick = "clawing"
   battler_claw_wound = "raking"
   battler_claw_damage = "rending"
   battler_claw_slay = "shredding"

   battler_sting_nick = "irritating"
   battler_sting_wound = "stinging"
   battler_sting_damage = "pricking"
   battler_sting_slay = "impaling"

   battler_punch_nick = "slapping"
   battler_punch_wound = "pummeling"
   battler_punch_damage = "mangling"
   battler_punch_slay = "thrashing"

   battler_slash_nick = "scraping"
   battler_slash_wound = "cutting"
   battler_slash_damage = "cleaving"
   battler_slash_slay = "gutting"

   battler_bludgeon_nick = "bashing"
   battler_bludgeon_wound = "crushing"
   battler_bludgeon_damage = "smashing"
   battler_bludgeon_slay = "brutalizing"

   battler_thrust_nick = "poking"
   battler_thrust_wound = "stabbing"
   battler_thrust_damage = "impaling"
   battler_thrust_slay = "running through"

   battler_pierce_nick = "grazing"
   battler_pierce_wound = "piercing"
   battler_pierce_damage = "lacerating"
   battler_pierce_slay = "felling"

classvars:

   viObject_flags = OF_ATTACKABLE

   viBattler_level = 50

properties:

   % Evil twin object
   poEvilTwin = $

   % Apparition list and target
   plApparitionList = $
   poApparitionOriginal = $

   % list of resistances, Each element is [value, type].
   plResistances = $

   % List of enchantments.
   % Each element is [ timer, object of spell, [optional state] ].
   plEnchantments = $

   % Combat modifiers. These are handled as deviations from the base value
   % expressed in per MILLE: A rating of 200 will enhance the base value by a
   % factor of 1.2.
   piCombatModDefense = 0
   piCombatModOffense = 0
   piCombatModMelee = 0
   piCombatModRanged = 0
   piCombatModMagic = 0

   % Factors that reduce damage taken by a percentage. Accurate to .1%
   piPhysicalReductionFactor = 0
   piMagicalReductionFactor = 0
   
   % Flat amounts of damage that are directly subtracted from damage taken. These 
   % use high precision.
   piPhysicalReductionFlat = 0
   piMagicalReductionFlat = 0

   % Base value that is added to the SP of any spell the battler casts.
   piSpellpowerMod = 0

   % Each element is [skillnum,skillmod]
   plSkillmods = $
   % Each element is [spellnum,spellmod]
   plSpellmods = $

   % This dummy weapon represents the battler's inherent weapon, be it fists,
   % claws or jaws and allows us to treat unarmed attacks like any other weapon 
   % attack.
   poMartial_weapon = $

   % This dummy weapon represents the battler's active touchattack and allows us
   % to treat touchattacks like any other weapon attack.
   poMagic_weapon = $

   % This list is created whenever the battler attacks and handles the possibility
   % of multiple swings.
   plSwings = $

   % Since we don't want to have all the swings at once, we use a timer.
   ptSwings = $

   % Items currently in use by the battler.
   plUsing = $

   % Default mana values.
   piMana = 20
   piMax_Mana = 20

   % Mana regen timer.
   ptMana = $

messages:

   % The first lump of code here deals with resistances and immunities/etc.
   % They are included here in battler so both user and mobiles can enjoy
   %  the effect.

   TryDeflect()
   {
      return FALSE;
   }
  
   ReqNewOwner(what = $)
   {
      return IsClass(what,&Room);
   }

   SayDyingWords(what=$)
   {
      return FALSE;
   }

   IsLikelyVictim()
   {
      % nearly all battlers can be attacked by a monster without provocation
      return TRUE;
   }

   IsUndead()
   {
      return FALSE;
   }

   % This checks if the battler can completely resist the effects of the spell.
   %  By default, the spell is not resisted.
   SpellResist(oSpell=$,who=$,iSpellpower=$)
   {
      return FALSE;
   }

   GetBaseResistances()
   "Many mobs have base resistances, but players do not. Monster.kod overwrites this."
   {
      return $;
   }
   
   GetCurrentResistances()
   "Object attributes, such as spells and items, can change resistances temporarily."
   {
      local oObjectAttribute, plCurrentResistances, oEquipment, oEnchantment;
      
      plCurrentResistances = Send(SYS,@ListCopy,#source=Send(self,@GetBaseResistances));
      
      for oObjectAttribute in plObject_attributes
      {
         plCurrentResistances = Send(oObjectAttribute,@ModifyResistance,#resistance_list=plCurrentResistances);
      }
      
      for oEquipment in Send(self,@GetEquippedItems)
      {
         plCurrentResistances = Send(oEquipment,@ModifyResistance,#resistance_list=plCurrentResistances);
      }
      
      If IsClass(self,&User)
      {
         for oEnchantment in Send(self,@GetEnchantmentList)
         {
            if Length(oEnchantment) > 2
            {
               plCurrentResistances = Send(Nth(oEnchantment,2),@ModifyResistance,#resistance_list=plCurrentResistances,#iState=Nth(oEnchantment,3));
            }
            else
            {
               plCurrentResistances = Send(Nth(oEnchantment,2),@ModifyResistance,#resistance_list=plCurrentResistances);
            }
         }
      }
      
      return plCurrentResistances;
   }

   % These messages allow us to set and retrieve combat mods.

   GetCombatModDefense()
   {
      return piCombatModDefense;
   }

   GetCombatModOffense()
   {
      return piCombatModOffense;
   }

   GetCombatModMelee()
   {
      return piCombatModMelee;
   }

   GetCombatModRanged()
   {
      return piCombatModRanged;
   }

   GetCombatModMagic()
   {
      return piCombatModMagic;
   }

   GetPhysicalReductionFactor()
   {
      return piPhysicalReductionFactor;
   }

   GetMagicalReductionFactor()
   {
      return piMagicalReductionFactor;
   }

   GetPhysicalReductionFlat()
   {
      return piPhysicalReductionFlat;
   }

   GetMagicalReductionFlat()
   {
      return piMagicalReductionFlat;
   }

   GetSpellpowerMod()
   {
      return piSpellpowerMod;
   }

   GetSkillmods()
   {
      return plSkillmods;
   }

   GetSpellmods()
   {
      return plSpellmods;
   }

   AddCombatModDefense(amount=0)
   {
      piCombatModDefense = piCombatModDefense + amount;
      
      return;
   }

   AddCombatModOffense(amount=0)
   {
      piCombatModOffense = piCombatModOffense + amount;
      
      return;
   }

   AddCombatModMelee(amount=0)
   {
      piCombatModMelee = piCombatModMelee + amount;
      
      return;
   }

   AddCombatModRanged(amount=0)
   {
      piCombatModRanged = piCombatModRanged + amount;
      
      return;
   }

   AddCombatModMagic(amount=0)
   {
      piCombatModMagic = piCombatModMagic + amount;
      
      return;
   }

   AddPhysicalReductionFactor(amount=0)
   {
      piPhysicalReductionFactor = piPhysicalReductionFactor + amount;
      
      return;
   }

   AddMagicalReductionFactor(amount=0)
   {
      piMagicalReductionFactor = piMagicalReductionFactor + amount;
      
      return;
   }

   AddPhysicalReductionFlat(amount=0)
   {
      piPhysicalReductionFlat = piPhysicalReductionFlat + amount;
      
      return;
   }

   AddMagicalReductionFlat(amount=0)
   {
      piMagicalReductionFlat = piMagicalReductionFlat + amount;
      
      return;
   }

   AddSpellpowerMod(amount=0)
   {
      piSpellpowerMod = piSpellpowerMod + amount;
      
      return;
   }

   AddSkillmod(num=0,amount=0)
   {
      local i, iTotal;
      
      for i in plSkillmods
      {
         if First(i) = num
         {
            iTotal = Nth(i,2) + amount;
            
            if iTotal <> 0
            {
               SetNth(i,2,iTotal);
            }
            else
            {
               plSkillmods = DelListElem(plSkillmods,i);
            }

            return;
         }
      }

      plSkillmods = Cons([num,amount],plSkillmods);

      return;
   }

   AddSpellmod(num=0,amount=0)
   {
      local i, iTotal;
      
      for i in plSpellmods
      {
         if First(i) = num
         {
            iTotal = Nth(i,2) + amount;
            
            if iTotal <> 0
            {
               SetNth(i,2,iTotal);
            }
            else
            {
               plSpellmods = DelListElem(plSpellmods,i);
            }

            return;
         }
      }

      plSpellmods = Cons([num,amount],plSpellmods);

      return;
   }

   % Returns weapon used.
   GetWeapon()
   {
      local oWeapon;

      if IsClass(self,&Player)
      {
         oWeapon = Send(self,@LookupPlayerWeapon);
      }
      else
      {
         oWeapon = $;
      }

      % If there is no wielded weapon, see if we have an active touch attack.
      if oWeapon = $
      {
         oWeapon = poMagic_weapon;

         % If there is no touch attack, he is using his fists.
         if oWeapon = $
         {
            oWeapon = poMartial_weapon;
         }
      }

      return oWeapon;
   }

   % Functions dealing with a player's magic and martial weapons.
   CreateMartialWeapon(cweapon=$,lstats=$)
   {
      if poMartial_weapon <> $
      {
         Send(poMartial_weapon,@Delete);
      }
      poMartial_weapon = Create(cweapon,#lstats=lstats);
      
      return poMartial_weapon;
   }

   GetMartialWeapon()
   {
      return poMartial_weapon;
   }

   DeleteMartialWeapon()
   {
      if poMartial_weapon <> $
      {
         Send(poMartial_weapon,@Delete);

         poMartial_weapon = $;
      }

      return;
   }

   CreateMagicWeapon(cweapon=$,lstats=$)
   {
      if poMagic_weapon <> $
      {
         Send(poMagic_weapon,@Delete);
      }
      poMagic_weapon = Create(cweapon,#lstats=lstats);
      
      return poMagic_weapon;
   }

   GetMagicWeapon()
   {
      return poMagic_weapon;
   }

   DeleteMagicWeapon()
   {
      if poMagic_weapon <> $
      {
         Send(poMagic_weapon,@Delete);

         poMagic_weapon = $;
      }

      return;
   }

   GetEquippedItems()
   "Support for items equipped by players, but also some monsters, such as troops."
   {
      return $;
   }
 
   ResistanceCheck(attacktype = 0, spelltype = 0)
   "Given bitvectors of attack type and spell, find the resistance modifier "
   "which applies. Largest resistance plus worst weakness gives the modifier."
   {
      local j, iResType, iMaxRes, iMinRes, iResistance, resistance_list;

      iMaxRes = NO_RESISTANCE;
      iMinRes = NO_RESISTANCE;
      
      resistance_list = Send(self,@GetCurrentResistances);

      for j in resistance_list
      {
         iResType = Nth(j,1);
         if iResType > 0   
         {
            % It's a resistance to weapon type

            if (attacktype & iResType) <> 0
               OR (attacktype <> 0 AND iResType = ATCK_WEAP_ALL)
            {
               iResistance = Nth(j,2);
               
               if iResistance > iMaxRes
               {
                  iMaxRes = iResistance;
               }

               if iResistance < iMinRes
               {
                  iMinRes = iResistance;
               }
            }
         }
         else
         {
            % It's a resistance to spell type
            iResType = -iResType;

            if (spelltype & iResType) <> 0
               OR (spelltype <> 0 AND iResType = ATCK_SPELL_ALL)
            {
               iResistance = Nth(j,2);
               
               if iResistance > iMaxRes
               {
                  iMaxRes = iResistance;
               }

               if iResistance < iMinRes
               {
                  iMinRes = iResistance;
               }
            }
         }
      }

      % clip to max/min values
      iMaxRes = bound(iMaxRes,$,MAX_RESISTANCE);
      iMinRes = bound(iMinRes,MIN_RESISTANCE,$);

      return iMaxRes + iMinRes;
   }

   GetDamageFromResistance(what = $, value = $)
   "Adjust <what> damage according to the value multiplier"
   {
      local iDamage;

      if value > NO_RESISTANCE
      {
         iDamage = what * (MAX_RESISTANCE - value) / MAX_RESISTANCE;
      }
      else
      {
         iDamage = what * (MIN_RESISTANCE + value) / MIN_RESISTANCE;
      }

      return iDamage;
   }

   %%% Spell enchantment functions.

   IsEnchanted(what=$,byClass=&Spell)
   "Returns whether or not currently enchanted by <what>."
   {
      local i;

      if what = $
      {
         for i in plEnchantments
         {
            if IsClass(Nth(i,2),byClass)
            {
               return TRUE;
            }
         }
      }
      else
      {
         for i in plEnchantments
         {
            if Nth(i,2) = what
            {
               return TRUE;
            }
         }
      }

      return FALSE;
   }

   GetEnchantedState(what=$)
   "If enchanted by <what>, returns the state data (which MUST exist, or it's an error.  "
   "In other words, the caller must know that <what> adds state data).  Returns $ otherwise."
   {
      local i;

      for i in plEnchantments
      {
         if Nth(i,2) = what
         {
            return Nth(i,3);
         }
      }

      return $;
   }

   GetEnchantmentsByClass(enchClass=&Spell)
   "returns a subset of plEnchantments whose elements are of the given class"
   {
      local i, returnList;
      returnList = $;

      for i in plEnchantments
      {
         if IsClass(Nth(i,2),enchClass)
         {
            returnList = Cons(i,returnList);
         }
      }

      return returnList;
   }

   GetEnchantmentList()
   {
      return plEnchantments;
   }

   GetCastPower(what=$)
   "This is used by purge to get the spellpower the personal enchantment was "
   "cast at. Put in Battler instead of Player as we may use this for monster "
   "buffs one day."
   {
      local i, iCastPower;

      for i in plEnchantments
      {
         if Nth(i,2) = what
         {
            if Length(i) > 3
            {
               iCastPower = Nth(i,4);
            }
            else
            {
               iCastPower = Nth(i,3);
            }
         }
      }

      return iCastPower;
   }

   %%% Mana related stuff common to players and mobs.

   GetMaxMana()
   {
      return piMax_mana;
   }

   GetMana()
   {
      return piMana;
   }

   ManaTimer()
   {
      ptMana = $;

      if piMana < piMax_mana
      {
         Send(self,@GainMana,#amount=1);
      }
      else
      {
         Send(self,@LoseMana,#amount=1);
      }

      return;
   }

   LoseMana(amount = 0)
   {
      local iManaLost;

      piMana = piMana - amount;
      if piMana < 0
      {
         iManaLost = amount - abs(piMana);
      }
      else
      {
         iManaLost = amount;
      }

      Send(self,@NewMana);

      return iManaLost;
   }

   GainMana(amount=0, bCapped=FALSE, bRespectMax=FALSE)
   {
      local iManaGained;

      iManaGained = amount;

      if IsClass(self,&Player)
         AND Send(self,@IsPhasedOut)
      {
         return 0;
      }

      if bRespectMax
         AND piMana + amount > piMax_mana
      {
         return 0;
      }

      piMana = piMana + amount;

      if bCapped AND piMana > piMax_Mana
      {
         iManaGained = amount - (piMana - piMax_Mana);
         piMana = piMax_Mana;
      }

      Send(self,@NewMana);

      return iManaGained;
   }

   NewMana()
   {
      if piMana < 0
      {
         piMana = 0;
      }

      if piMana <> piMax_mana AND ptMana = $
      {
         ptMana = CreateTimer(self,@ManaTimer,Send(self,@CalculateManaTime));
      }

      if piMana = piMax_mana AND ptMana <> $
      {
         DeleteTimer(ptMana);
         ptMana = $;
      }

      if IsClass(self,&Player)
      {
         Send(self,@DrawMana);
      }

      return;
   }

   %%% Combat functionality.

   % All conditions have been checked at this point and the battler is eligible
   % to attack his target. TryAttack figures out whether he hits the target
   % based on his offense and the target's defense and passes this information
   % on to AssessDamage, AssessHit/AssessMiss etc.
   %
   % NOTES on settings: piEqualChanceToHit, piBaseRating and piDamageScaling can
   % be adjusted in settings.kod to tweak the calculations.
   % piEqualChanceToHit: This is the chance for an attacker to hit his target if
   % his defense equals the target's offense. A setting of 500 is equivalent to 
   % a 50 percent chance to hit.
   % piBaseRating: This is a flat number that serves as a base value for defense
   % and offense, softening the effect of any modifiers and avoiding
   % pathological ratios when one of the two battler's rating is extremely low.
   % piDamageScaling: This allows damage to scale when chance to hit exceeds 100
   % percent, allowing offense to be useful even when the target has very low
   % defense and we hit with every attack. People are less and less likely to 
   % run into this cap as piBaseRating is increased though.
   TryAttack(what=$,use_weapon=$,stroke_obj=$)
   {
      local iOffense, iDefense, iChanceToHit, iSwings;

      iOffense = Send(self,@GetOffense,#what=what,#use_weapon=use_weapon,
         #stroke_obj=stroke_obj) + Send(Send(SYS,@GetSettings),@GetBaseRating);
      iDefense = Send(what,@GetDefense,#what=self,#use_weapon=use_weapon,
         #stroke_obj=stroke_obj) + Send(Send(SYS,@GetSettings),@GetBaseRating);
      iChanceToHit = iOffense * Send(Send(SYS,@GetSettings),@GetEqualChanceToHit) / iDefense;
      iChanceToHit = bound(iChanceToHit,125,2000);

      % We may do more than one swing per attack. Ask ourselves how many we do.
      iSwings = Send(self,@GetSwings,#use_weapon=use_weapon);

      plSwings = [iSwings,iChanceToHit,what,use_weapon,stroke_obj];

      Send(self,@CarryOutAttack);

      if poOwner <> $
      {
         Send(poOwner,@SomethingAttacked,#what=self,#victim=what,
              #use_weapon=use_weapon);
      }

      return TRUE;
   }

   % This carries out an actual swing, allowing TryAttack to queue multiple ones up.
   CarryOutAttack()
   {
      local iChanceToHit, what, use_weapon, stroke_obj,
         iScalefactor, iDamage, attacktype, spelltype, iReduction;

      if ptSwings <> $
      {
         ptSwings = $;
      }

      iChanceToHit = Nth(plSwings,2);
      what = Nth(plSwings,3);
      use_weapon = Nth(plSwings,4);
      stroke_obj = Nth(plSwings,5);

      % Double check to make sure our target is still alive and in the same room.
      % If not, reset our swing list and return.
      if (what = $) OR (poOwner <> Send(what,@GetOwner))
      {
         plSwings = $;
         return;
      }

      % In case our chance to hit is greater than 100 percent, we may scale damage
      % accordingly. This depends on our settings though.
      if iChanceToHit > 1000 AND Send(Send(SYS,@GetSettings),@GetDamageScaling)
      {
         iScalefactor = iChanceToHit;
      }
      else
      {
         iScalefactor = 1000;
      }

      if iChanceToHit >= random(1,1000)
      {
         % We hit!
         % Ask the battler, which asks the stroke, which asks the weapon, each 
         % modifying damage accordingly.
         iDamage = Send(self,@GetDamage,#what=what,#use_weapon=use_weapon,
            #stroke_obj=stroke_obj);

         % Also figure attack and spell types.
         attacktype = Send(use_weapon,@GetAttackType);
         spelltype = Send(use_weapon,@GetSpellType);

         % Figure out the damage reduction before resistances.
         iReduction = Send(what,@GetDamageReduction,#damage=iDamage,
            #attacktype=attacktype,#spelltype=spelltype);

         iDamage = Send(what,@AssessDamage,#what=self,#damage=iDamage,
            #reduction=iReduction,#attacktype=attacktype,#spelltype=spelltype,
            #scalefactor=iScalefactor,#precision=TRUE);

         Send(self,@AssessHit,#what=what,#stroke_obj=stroke_obj,
            #use_weapon=use_weapon,#damage=iDamage,#reduction=iReduction);

         if iDamage = $
         {
            Send(self,@KilledSomething,#what=what,#use_weapon=use_weapon,#stroke_obj=stroke_obj);
         }
         else
         {
            Send(self,@DidDamage,#amount=iDamage,#what=what,#use_weapon=use_weapon);
         }
      }
      else
      {
         % Oops, a miss.  See if something happens.
         Send(self,@AssessMiss,#what=what,#stroke_obj=stroke_obj);
      }

      Setnth(plSwings,1,First(plSwings)-1);

      if First(plSwings) > 0 AND iDamage <> $
      {
         ptSwings = CreateTimer(self,@CarryOutAttack,200);
      }
      else
      {
         plSwings = $;
      }

      return;
   }

   GetSwings(use_weapon=$)
   {
      return 1;
   }
   
   GetLevel()
   {
      return 65;
   }

   GetOffense(what = $, stroke_obj=$)
   "Returns the battler's ability to-hit.  Ranges from 1 to 3000."
   {
      return 1;
   }

   GetDefense(what = $, stroke_obj=$)
   "Returns the battler's ability to avoid being hit.  Ranges from 1 to 3000."
   {
      return 1;
   }

   GetDamage(what = $, stroke_obj=$)
   "Returns the damage done to target 'what'."
   {
      return 0;
   }

   GetAttackType(what = $)
   "Returns the weapon type of damage done."
   {
      % Default type for the stub function.
      return ATCK_WEAP_HIT;
   }

   GetSpellType(what = $)
   "This is the magical type of damage done."
   {
      % Default, no spells
      return 0;
   }

   AssessDamage(what = $,damage = $,attacktype = $, spelltype = $)
   "This applies damage to the battler, calculating appropriate resistances.  "
   "Return $ if we were killed."
   {
      return 0;
   }

   GetDamageDesc(damage=0, type=0)
   "This returns the severity of damage by type.  Gives a verb descriptor."
   {
      % For each type, Send unique words to describe the damage
      if type < 0
      {
         type = -type;
         if (type & ATCK_SPELL_FIRE)
         {
            if damage = $
            {
               return battler_fire_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_fire_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_fire_wound;
            }

            return battler_fire_nick;

         }

         if (type & ATCK_SPELL_SHOCK)
         {
            if damage = $
            {
               return battler_shock_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_shock_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_shock_wound;
            }

            return battler_shock_nick;
         }

         if (type & ATCK_SPELL_COLD)
         {
            if damage = $
            {
               return battler_cold_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_cold_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_cold_wound;
            }

            return battler_cold_nick;
         }

         if (type & ATCK_SPELL_ACID)
         {
            if damage = $
            {
               return battler_acid_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_acid_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_acid_wound;
            }

            return battler_acid_nick;
         }

         if (type & ATCK_SPELL_HOLY)
         {
            if damage = $
            {
               return battler_holy_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_holy_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_holy_wound;
            }

            return battler_holy_nick;
         }

         if (type & ATCK_SPELL_UNHOLY)
         {
            if damage = $
            {
               return battler_unholy_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_unholy_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_unholy_wound;
            }

            return battler_unholy_nick;
         }

         if (type & ATCK_SPELL_QUAKE)
         {
            if damage = $
            {
               return battler_quake_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_quake_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_quake_wound;
            }

            return battler_quake_nick;
         }
      }
      else
      {
         if (type & ATCK_WEAP_BITE)
         {
            if damage = $
            {
               return battler_bite_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_bite_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_bite_wound;
            }

            return battler_bite_nick;
         }

         if (type & ATCK_WEAP_CLAW)
         {
            if damage = $
            {
               return battler_claw_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_claw_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_claw_wound;
            }

            return battler_claw_nick;
         }

         if (type & ATCK_WEAP_STING)
         {
            if damage = $
            {
               return battler_sting_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_sting_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_sting_wound;
            }

            return battler_sting_nick;
         }

         if (type & ATCK_WEAP_PUNCH)
         {
            if damage = $
            {
               return battler_punch_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_punch_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_punch_wound;
            }

            return battler_punch_nick;
         }

         if (type & ATCK_WEAP_SLASH)
         {
            if damage = $
            {
               return battler_slash_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_slash_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_slash_wound;
            }

            return battler_slash_nick;
         }

         if (type & ATCK_WEAP_BLUDGEON)
         {
            if damage = $
            {
               return battler_bludgeon_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_bludgeon_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_bludgeon_wound;
            }

            return battler_bludgeon_nick;
         }

         if (type & ATCK_WEAP_THRUST)
         {
            if damage = $
            {
               return battler_thrust_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_thrust_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_thrust_wound;
            }

            return battler_thrust_nick;
         }

         if (type & ATCK_WEAP_PIERCE)
         {
            if damage = $
            {
               return battler_pierce_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_pierce_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_pierce_wound;
            }

            return battler_pierce_nick;
         }
      }
      
      % Use these as the "default"
      if damage = $
      {
         return battler_slay;
      }

      if damage > DAMAGE_THRESHOLD_DAMAGE
      {
         return battler_damage;
      }

      if damage > DAMAGE_THRESHOLD_WOUND
      {
         return battler_wound;
      }

      return battler_nick;
   }

   % This returns defense reason of why opponent missed this battler.
   GetDefenseDesc(stroke_obj=$)
   {
      local iRandom, iParry, iBlock, iDodge;
      
      iParry = Send(self,@GetParryAbility,#stroke_obj=stroke_obj);
      iBlock = Send(self,@GetBlockAbility,#stroke_obj=stroke_obj);
      iDodge = Send(self,@GetDodgeAbility,#stroke_obj=stroke_obj);
      iRandom = iParry + iBlock + iDodge + BATTLER_AVOID_CHANCE;
      iRandom = random(0,iRandom);

      if iRandom < iParry
      {
         return battler_parried;
      }

      if iRandom < (iParry + iBlock)
      {
         return battler_blocked;
      }

      if iRandom < (iParry + iBlock + iDodge)
      {
         return battler_dodged;
      }
      
      return battler_misses;
   }

   % The next three messages deal with the three defense skills.  These
   %  messages return the relative values of the three skills.  Used in
   %  player for defense, used in battler for defense messages.

   GetParryAbility(stroke_obj=$)
   {
      return 0;
   }

   GetBlockAbility(stroke_obj=$)
   {
      return 0;
   }

   GetDodgeAbility(stroke_obj=$)
   {
      return 0;
   }

   AssessHit(what = $, stroke_obj = $, use_weapon=$, damage = $, reduction = 0)
   "This does the fallout of a hit, gives appropriate message, etc.  "
   "Called on self when hit opponent."
   {
      local rWeaponName, iDmg, rDamageDesc, iType, rStrokeFirst, rStrokeThird,
      battler_attacker_hit, battler_attacker_slay, battler_attacker_fail,
      battler_defender_hit, battler_defender_slay, battler_defender_fail,
      rDamage,rAbsorb,bAccuracy;

      bAccuracy = Send(Send(SYS,@GetSettings),@GetAccuracy);

      rWeaponName = Send(use_weapon,@GetAttackName);

      if damage <> $
      {
         if bAccuracy
         {
            rDamage = Send(SYS,@IntToString,#num=damage,#decimals=2);
         }
         else
         {
            rDamage = Send(SYS,@IntToString,#num=damage/100);
         }
      }

      % Create the absorb string. Leave it empty if nothing has been absorbed.
      rAbsorb = CreateString();
      ClearTempString();
      if (bAccuracy AND reduction > 0 ) OR reduction > 99
      {
         AppendTempString("~y~B(");
         if bAccuracy
         {
            Send(SYS,@IntToString,#num=reduction,#decimals=2,#append=TRUE);
         }
         else
         {
            Send(SYS,@IntToString,#num=reduction/100,#append=TRUE);
         }
         AppendTempString(")~B");
      }
      else
      {
         AppendTempString("");
      }
      SetString(rAbsorb,GetTempString());

      if stroke_obj <> $
      {
         rStrokeFirst = Send(stroke_obj,@GetStrokeFirstPerson);
         rStrokeThird = Send(stroke_obj,@GetStrokeThirdPerson);
      }
      else
      {
         rStrokeFirst = battler_no_stroke_first;
         rStrokeThird = battler_no_stroke_third;
      }

      % Spell types are usually represented by negative values, to
      %  differentiate between physical and spell damage.
      iType = Send(use_weapon,@GetSpellType,#use_weapon=use_weapon);

      % We only want to use a unique word if the spell damage is NOT generic
      %  or Hunter sword damage.  Otherwise, use the physical damage type.
      if (iType & (~ATCK_SPELL_HUNTERSWORD | ~ATCK_SPELL_ALL)) = 0
      {
         iType = Send(use_weapon,@GetAttackType);
      }
      else
      {
         % Make it negative to distinguish between physical types.
         iType = -iType;
      }

      if IsClass(what,&Player)
         AND damage <> $
         AND damage >= (Send(what,@GetMaxHealth)*33)
      {
         % If we did at least 1/3 a player's hps in damage, then give
         %  the best damage message.
         iDmg = (DAMAGE_THRESHOLD_DAMAGE + 1);
      }
      else
      {
         iDmg = damage;
      }

      rDamageDesc = Send(self,@GetDamageDesc,#damage=iDmg,#type=iType);  

      if IsClass(self,&Player)
      {
         if IsClass(what,&Player) AND NOT Send(what,@CheckPlayerFlag,#flag=PFLAG_MORPHED) 
         {
            battler_attacker_hit = battler_attacker_hit_plain;
            battler_attacker_slay = battler_attacker_slay_plain;
            battler_attacker_fail = battler_attacker_fail_plain;
         }
         else
         {
            battler_attacker_hit = battler_attacker_hit_blue;
            battler_attacker_slay = battler_attacker_slay_blue;
            battler_attacker_fail = battler_attacker_fail_blue;
         }

         if what <> self
         {
            if damage = $
            {
               Send(self,@MsgSendUser,#message_rsc=battler_attacker_slay,
                  #parm1=rStrokeFirst,#parm2=Send(what,@GetDef),#parm3=Send(what,@GetName),
                  #parm4=rWeaponName,#parm5=rDamageDesc,#parm6=Send(what,@GetHimHer));
            }
            else
            {
               if (bAccuracy AND damage > 0 ) OR damage > 99
               {
                  Send(self,@MsgSendUser,#message_rsc=battler_attacker_hit,
                     #parm1=rStrokeFirst,#parm2=Send(what,@GetDef),#parm3=Send(what,@GetName),
                     #parm4=rWeaponName,#parm5=rDamageDesc,#parm6=Send(what,@GetHimHer),
                     #parm7=rDamage,#parm8=rAbsorb);
               }
               else
               {
                  Send(self,@MsgSendUser,#message_rsc=battler_attacker_fail,
                  #parm1=rStrokeFirst,#parm2=Send(what,@GetDef),#parm3=Send(what,@GetName),
                  #parm4=rWeaponName);
               }
            }
         }
      }

      if IsClass(what,&Player)
      {
         if IsClass(self,&Player) AND NOT Send(self,@CheckPlayerFlag,#flag=PFLAG_MORPHED) 
         {
            battler_defender_hit = battler_defender_hit_plain;
            battler_defender_slay = battler_defender_slay_plain;
            battler_defender_fail = battler_defender_fail_plain;
         }
         else
         {
            battler_defender_hit = battler_defender_hit_blue;
            battler_defender_slay = battler_defender_slay_blue;
            battler_defender_fail = battler_defender_fail_blue;
         }
      
         if damage = $
         {   
            Send(what,@MsgSendUser,#message_rsc=battler_defender_slay,
            #parm1=Send(self,@GetCapDef),#parm2=Send(self,@GetName),
            #parm3=rStrokeThird,#parm4=Send(self,@GetHisHer),#parm5=rWeaponName,
            #parm5=rDamageDesc);
         }
         else
         {
            if (bAccuracy AND damage > 0 ) OR damage > 99
            {
               Send(what,@MsgSendUser,#message_rsc=battler_defender_hit,
                  #parm1=Send(self,@GetCapDef),#parm2=Send(self,@GetName),
                  #parm3=rStrokeThird,#parm4=Send(self,@GetHisHer),#parm5=rWeaponName,
                  #parm6=rDamageDesc,#parm7=rDamage,#parm8=rAbsorb);
            }
            else
            {
               Send(what,@MsgSendUser,#message_rsc=battler_defender_fail,
                  #parm1=Send(self,@GetCapDef),#parm2=Send(self,@GetName),
                  #parm3=rStrokeThird,#parm4=Send(self,@GetHisHer),
                  #parm5=rWeaponName);
            }
         }
      }

      return;
   }

   AssessMiss(what = $, stroke_obj = $)
   "This does the fallout of a miss, gives appropriate message, etc. "
   "Called on self when missing."
   {
      local battler_attacker_miss, battler_defender_miss, rActionNoun;

      rActionNoun = Send(stroke_obj,@GetActionNoun);

      if IsClass(self,&Player)
      {
         if IsClass(what,&Player) AND NOT Send(what,@CheckPlayerFlag,#flag=PFLAG_MORPHED) 
         {
            battler_attacker_miss = battler_attacker_miss_plain;
         }
         else
         {
            battler_attacker_miss = battler_attacker_miss_blue;
         }

         Send(self,@MsgSendUser,#message_rsc=battler_attacker_miss,
              #parm1=rActionNoun,#parm2=Send(what,@GetDefenseDesc,
              #stroke_obj=stroke_obj),#parm3=Send(what,@GetDef),
              #parm4=Send(what,@GetName));
         Send(stroke_obj,@SendMissSound,#who=self,#victim=what,
              #use_weapon=Send(self,@LookupPlayerWeapon));
      }

      if IsClass(what,&Player)
      {
         if IsClass(self,&Player) AND NOT Send(self,@CheckPlayerFlag,#flag=PFLAG_MORPHED) 
         {
            battler_defender_miss = battler_defender_miss_plain;
         }
         else
         {
            battler_defender_miss = battler_defender_miss_blue;
         }
      
         Send(what,@MsgSendUser,#message_rsc=battler_defender_miss,
              #parm1=Send(self,@GetCapDef),#parm2=Send(self,@GetName),
              #parm3=rActionNoun,#parm4=Send(what,@GetDefenseDesc,
              #stroke_obj=stroke_obj));
         % Flag them as "dodging", so they can potentially improve.
         Send(what,@SetPlayerFlag,#flag=PFLAG_DODGED,#value=TRUE);              
      }

      return;
   }

   % This function handles when damage is done by attacker.
   DidDamage(what=$, amount=0)
   {
      return;
   }

   % This function is called when we killed something.
   KilledSomething(what=$,use_weapon=$,stroke_obj=$)
   {
      return;
   }

   % Oo, 'e died
   Killed(what = $)
   {
      return;
   }

   MsgPlayerHitResisted()
   {
      return;
   }
   
   GetResistances()
   {
      return Send(self,@GetCurrentResistances);
   }
   
   GetResistanceValueByType(type=$)
   {
      local oResist;
      
      for oResist in Send(self,@GetCurrentResistances)
      {
         if Nth(oResist,1) = type
         {
            return Nth(oResist,2);
         }
      }
      
      return 0;
   }

   % This section deals with illusions cast by/on the battler

   AddEvilTwin(what=$)
   {
      if poEvilTwin=$
      {
         poEvilTwin=what;

         return TRUE;
      }

      return FALSE;
   }

   RemoveEvilTwin()
   {
      if poEvilTwin <> $
      {
         poEvilTwin = $;

         return TRUE;
      }

      return FALSE;
   }

   HasEvilTwin()
   {
      if poEvilTwin <> $
      {
         return TRUE;
      }

      return FALSE;
   }

   % If Apparition is cast on the monster, this list keeps track of it.
   AddApparition(what=$)
   {
      plApparitionList = Cons(what,plApparitionList);

      return;
   }

   % If this monster is an Apparition, this keeps track of the original target.
   AddApparitionOriginal(what=$)
   {
      poApparitionOriginal = what;

      return;
   }

   % If an Apparition targeting this monster is deleted, remove it from list.
   RemoveApparition(what=$)
   {
      local i;

      for i in plApparitionList
      {
         if i = what
         {
            plApparitionList = DelListElem(plApparitionList,i);
         }
      }

      if Length(plApparitionList) = 0
         {
            plApparitionList = $;
         }

      return;
   }

end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

