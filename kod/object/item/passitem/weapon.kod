% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% All rights reserved.
%
% This software is distributed under a license that is described in
% the LICENSE file that accompanies it.
%
% Meridian is a registered trademark.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Weapon is PassiveItem

constants:

   include blakston.khd

   USED = 1
   UNUSED = 2
   ATTACKING = 3

   WEAPON_TAKE_DAMAGE_PCT = 75

resources:

   weapon_already_broken = "%s%s is broken; you can't use it!"
   weapon_broken = "%s%s shatters into pieces."

   weapon_condition_exc = " is in flawless condition."
   weapon_condition_exc_mended = " is in excellent condition, but has been repaired before."
   weapon_condition_good = " is slightly tarnished but in generally good condition."
   weapon_condition_med = " is notched and stained with blood but is still an effective weapon."
   weapon_condition_poor = " is well worn and may not last much longer."
   weapon_condition_broken = " has been shattered by a powerful blow."

   weapon_do_damage = "I just did %i points of damage! (%i)"
   weapon_to_hit = "I have a %i chance to hit! (%i/%i)"

   % These are used by weapon enchantments to tell where some symbol
   %  happens to be on the blade.
   weapon_head = "on the head"
   weapon_grip = "on the grip"

classvars:

   viUse_type = ITEM_USE_HAND
   viItem_Type = ITEMTYPE_WEAPON
   viUse_amount = 1

   vrPoss_article_rsc = object_article_cap_this_rsc

   %if not nil, the weapon will check for ammo in the ITEM_USE_QUIVER slot
   %added to player.kod and remove one--ammo is a numbered item
   vcAmmo = $

   vrWeapon_window_overlay = $
   vrWeapon_window_attack_start = 1
   vrWeapon_window_attack_end = 4
   vrWeapon_window_hold = 5

   vrWeapon_overlay = $

   % if it's set to a number, it's always used
   viBroken_group = $
   % Message when the weapon breaks.
   vrWeaponBroke = weapon_broken
   
   viProficiency_needed = SKID_PROFICIENCY_SWORD

   viHits_init_min = 500
   viHits_init_max = 500

   vbShow_condition = TRUE
   vrCondition_exc = weapon_condition_exc 
   vrCondition_exc_mended = weapon_condition_exc_mended 
   vrCondition_good = weapon_condition_good 
   vrCondition_med = weapon_condition_med 
   vrCondition_poor = weapon_condition_poor 
   vrCondition_broken = weapon_condition_broken
   
   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   % These are the default values for the properties below. piQuality          %
   % is calculated based on deviations from these values.                      %
   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   % Self explanatory. Value inflated by a factor of 100 throughout damage
   % calculations to reduce truncation issues to a minimum.
   viDamage = 500
   % The amount of damage that proficiency in the weapon can add.
   viProficiencyBonus = 500
   % This is directly added to offense rating in GetOffense.
   viHitMod = 0
   % The percentage of extra damage that the weapon's primary stat will add at 50.
   viPrimaryScaling = 30
   % The percentage of extra effect that the weapon's secondary stat will add at 50.
   viSecondaryScaling = 30
   % The percentage of damage the weapon will do with the respective stroke.
   viStab = 100
   viStrike = 100
   viSlash = 100
   viThrust = 100
   viFire = 100
   viTouch = 100
   % The percentage by which the player's ability in the skill is modified.
   viDisarmMod = 0
   viParryMod = 0
   % The amount of spellpower the weapon adds.
   viSpellpowerMod = 0
   % The range of the weapon in fine grain. One regular unit is split up into
   % 64 fine grain units. 192 = 64 * 3
   viRange = 192

   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   % These are the default values for the 'non power properties'.              %
   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   viPrimaryStat = STAT_MIGHT
   viSecondaryStat = STAT_MIGHT
   viAttackType = 0
   viSpellType = 0
   viDeviation = 20
   
properties:

   piDamage = 0
   piProficiencyBonus = 0
   piHitMod = 0
   piPrimaryScaling = 0
   piSecondaryScaling = 0
   piStab = 0
   piStrike = 0
   piSlash = 0
   piThrust = 0
   piFire = 0
   piTouch = 0
   piDisarmMod = 0
   piParryMod = 0
   piSpellpowerMod = 0
   piRange = 0
   piPrimaryStat = 0
   piSecondaryStat = 0
   piAttackType = 0
   piSpellType = 0
   piDeviation = 0
   piQuality = 100

   piUsed = UNUSED

messages:

   % Properties are set here and randomized later on in Constructed().
   DefaultValues()
   {
      local i, oItemAtt;

      piDamage = viDamage;
      piProficiencyBonus = viProficiencyBonus;
      piHitMod = viHitMod;
      piPrimaryScaling = viPrimaryScaling;
      piSecondaryScaling = viSecondaryScaling;
      piStab = viStab;
      piStrike = viStrike;
      piSlash = viSlash;
      piThrust = viThrust;
      piFire = viFire;
      piTouch = viTouch;
      piDisarmMod = viDisarmMod;
      piParryMod = viParryMod;
      piSpellpowerMod = viSpellpowerMod;
      piRange = viRange;
      piPrimaryStat = viPrimaryStat;
      piSecondaryStat = viSecondaryStat;
      piAttackType = viAttackType;
      piSpellType = viSpellType;
      piDeviation = viDeviation;

      % In case we have an item attribute that altered our spelltype, remove
      % that as well.
      for i in plItem_Attributes
      {
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=Send(self,@GetNumFromCompound,
            #compound=First(i)));
         if IsClass(oItemAtt,&WeapAttSpellType)
         {
            Send(oItemAtt,@RemoveFromItem,#oItem=self);
         }
      }
   
      return;
   }

   % Constructor has not been provided with the weapon's stats and the weapon
   % has been constructed from its default values instead. In this message, we 
   % randomize stats based on the lower and upper bounds for deviation. Item 
   % quality and durability are then figured from the average deviation.
   Constructed(lower=0,upper=0)
   {
      local n, iDeviation, iQuality;

      n = 0;
      iQuality = 0;
   
      if piDamage <> 0
      {
         n = n + 1;
         iDeviation = random(lower,upper);
         iQuality = iQuality + iDeviation;
         piDamage = piDamage*(100+iDeviation)/100;
      }
      if piProficiencyBonus <> 0
      {
         n = n + 1;
         iDeviation = random(lower,upper);
         iQuality = iQuality + iDeviation;
         piProficiencyBonus = piProficiencyBonus*(100+iDeviation)/100;   
      }
      if piHitMod > 0
      {
         n = n + 1;
         iDeviation = random(lower,upper);
         iQuality = iQuality + iDeviation;
         piHitMod = piHitMod*(100+iDeviation)/100;   
      }
      if piHitMod < 0
      {
         n = n + 1;
         iDeviation = random(-upper,lower);
         iQuality = iQuality - iDeviation;
         piHitMod = piHitMod*(100+iDeviation)/100;   
      }
      if piPrimaryScaling <> 0
      {
         n = n + 1;
         iDeviation = random(lower,upper);
         iQuality = iQuality + iDeviation;
         piPrimaryScaling = piPrimaryScaling*(100+iDeviation)/100;   
      }
      if piSecondaryScaling <> 0
      {
         n = n + 1;
         iDeviation = random(lower,upper);
         iQuality = iQuality + iDeviation;
         piSecondaryScaling = piSecondaryScaling*(100+iDeviation)/100;   
      }
      if piStab <> 0
      {
         n = n + 1;
         iDeviation = random(lower,upper);
         iQuality = iQuality + iDeviation;
         piStab = piStab*(100+iDeviation)/100;   
      }
      if piStrike <> 0
      {
         n = n + 1;
         iDeviation = random(lower,upper);
         iQuality = iQuality + iDeviation;
         piStrike = piStrike*(100+iDeviation)/100;   
      }
      if piSlash <> 0
      {
         n = n + 1;
         iDeviation = random(lower,upper);
         iQuality = iQuality + iDeviation;
         piSlash = piSlash*(100+iDeviation)/100;   
      }
      if piThrust <> 0
      {
         n = n + 1;
         iDeviation = random(lower,upper);
         iQuality = iQuality + iDeviation;
         piThrust = piThrust*(100+iDeviation)/100;   
      }
      if piFire <> 0
      {
         n = n + 1;
         iDeviation = random(lower,upper);
         iQuality = iQuality + iDeviation;
         piFire = piFire*(100+iDeviation)/100;   
      }
      if piTouch <> 0
      {
         n = n + 1;
         iDeviation = random(lower,upper);
         iQuality = iQuality + iDeviation;
         piTouch = piTouch*(100+iDeviation)/100;   
      }
      if piDisarmMod <> 0 AND piDisarmMod <> $
      {
         n = n + 1;
         iDeviation = random(lower,upper);
         iQuality = iQuality + iDeviation;
         piDisarmMod = piDisarmMod*(100+iDeviation)/100;   
      }
      if piParryMod <> 0 AND piParryMod <> $
      {
         n = n + 1;
         iDeviation = random(lower,upper);
         iQuality = iQuality + iDeviation;
         piParryMod = piParryMod*(100+iDeviation)/100;   
      }
      if piSpellpowerMod > 0
      {
         n = n + 1;
         iDeviation = random(lower,upper);
         iQuality = iQuality + iDeviation;
         piSpellpowerMod = piSpellpowerMod*(100+iDeviation)/100;   
      }
      if piSpellpowerMod < 0
      {
         n = n + 1;
         iDeviation = random(-upper,lower);
         iQuality = iQuality - iDeviation;
         piSpellpowerMod = piSpellpowerMod*(100+iDeviation)/100;   
      }
      if piRange <> 0
      {
         n = n + 1;
         iDeviation = random(lower,upper);
         iQuality = iQuality + iDeviation;
         piRange = piRange*(100+iDeviation)/100;   
      }

      if n > 0
      {
         iQuality = iQuality/n;
      }

      % Set the quality
      piQuality = 100 + iQuality;

      % Scale durability with quality.
      piHits_init = bound(piHits_init * piQuality / 100,1,$);
      piHits = bound(piHits * piQuality / 100,1,$);

      propagate;
   }

   % Constructor has received a list of stats, which are now written to the
   % item. Item quality and durability are figured by comparing the set stats to
   % the item's default values.
   SetStats(lstats=$)
   {
      local n, iDeviation, iQuality;

      n = 0;
      iQuality = 0;
   
      if viDamage <> 0
      {
         n = n + 1;
         iDeviation = 100*First(lstats)/viDamage - 100;
         iDeviation = bound(iDeviation,-100,100);
         iQuality = iQuality + iDeviation;
      }
      piDamage = First(lstats);

      if viProficiencyBonus <> 0
      {
         n = n + 1;
         iDeviation = 100*Nth(lstats,2)/viProficiencyBonus - 100;
         iDeviation = bound(iDeviation,-100,100);
         iQuality = iQuality + iDeviation;
      }
      piProficiencyBonus = Nth(lstats,2);

      if viHitMod > 0 AND Nth(lstats,3) > 0
      {
         n = n + 1;
         iDeviation = 100*Nth(lstats,3)/viHitMod - 100;
         iDeviation = bound(iDeviation,-100,100);
         iQuality = iQuality + iDeviation;
      }
      
      if viHitMod < 0 AND Nth(lstats,3) < 0
      {
         n = n + 1;
         iDeviation = 100*Nth(lstats,3)/viHitMod - 100;
         iDeviation = bound(iDeviation,-100,100);
         iQuality = iQuality - iDeviation;
      }
      piHitMod = Nth(lstats,3);

      if viPrimaryScaling <> 0
      {
         n = n + 1;
         iDeviation = 100*Nth(lstats,4)/viPrimaryScaling - 100;
         iDeviation = bound(iDeviation,-100,100);
         iQuality = iQuality + iDeviation;
      }
      piPrimaryScaling = Nth(lstats,4);

      if viSecondaryScaling <> 0
      {
         n = n + 1;
         iDeviation = 100*Nth(lstats,5)/viSecondaryScaling - 100;
         iDeviation = bound(iDeviation,-100,100);
         iQuality = iQuality + iDeviation;
      }
      piSecondaryScaling = Nth(lstats,5);

      if viStab <> 0
      {
         n = n + 1;
         iDeviation = 100*Nth(lstats,6)/viStab - 100;
         iDeviation = bound(iDeviation,-100,100);
         iQuality = iQuality + iDeviation;
      }
      piStab = Nth(lstats,6);

      if viStrike <> 0
      {
         n = n + 1;
         iDeviation = 100*Nth(lstats,7)/viStrike - 100;
         iDeviation = bound(iDeviation,-100,100);
         iQuality = iQuality + iDeviation;
      }
      piStrike = Nth(lstats,7);

      if viSlash <> 0
      {
         n = n + 1;
         iDeviation = 100*Nth(lstats,8)/viSlash - 100;
         iDeviation = bound(iDeviation,-100,100);
         iQuality = iQuality + iDeviation;
      }
      piSlash = Nth(lstats,8);

      if viThrust <> 0
      {
         n = n + 1;
         iDeviation = 100*Nth(lstats,9)/viThrust - 100;
         iDeviation = bound(iDeviation,-100,100);
         iQuality = iQuality + iDeviation;
      }
      piThrust = Nth(lstats,9);

      if viFire <> 0
      {
         n = n + 1;
         iDeviation = 100*Nth(lstats,10)/viFire - 100;
         iDeviation = bound(iDeviation,-100,100);
         iQuality = iQuality + iDeviation;
      }
      piFire = Nth(lstats,10);

      if viTouch <> 0
      {
         n = n + 1;
         iDeviation = 100*Nth(lstats,11)/viTouch - 100;
         iDeviation = bound(iDeviation,-100,100);
         iQuality = iQuality + iDeviation;
      }
      piTouch = Nth(lstats,11);

      if viDisarmMod <> 0 AND viDisarmMod <> $
      {
         n = n + 1;
         iDeviation = 100*Nth(lstats,12)/viDisarmMod - 100;
         iDeviation = bound(iDeviation,-100,100);
         iQuality = iQuality + iDeviation;
      }
      piDisarmMod = Nth(lstats,12);

      if viParryMod <> 0 AND viParryMod <> $
      {
         n = n + 1;
         iDeviation = 100*Nth(lstats,13)/viParryMod - 100;
         iDeviation = bound(iDeviation,-100,100);
         iQuality = iQuality + iDeviation;
      }
      piParryMod = Nth(lstats,13);

      if viSpellpowerMod > 0 AND Nth(lstats,14) > 0
      {
         n = n + 1;
         iDeviation = 100*Nth(lstats,14)/viSpellpowerMod - 100;
         iDeviation = bound(iDeviation,-100,100);
         iQuality = iQuality + iDeviation;
      }
      
      if viSpellpowerMod < 0 AND Nth(lstats,14) < 0
      {
         n = n + 1;
         iDeviation = 100*Nth(lstats,14)/viSpellpowerMod - 100;
         iDeviation = bound(iDeviation,-100,100);
         iQuality = iQuality - iDeviation;
      }
      piSpellpowerMod = Nth(lstats,14);

      if viRange <> 0
      {
         n = n + 1;
         iDeviation = 100*Nth(lstats,15)/viRange - 100;
         iDeviation = bound(iDeviation,-100,100);
         iQuality = iQuality + iDeviation;
      }
      piRange = Nth(lstats,15);

      % These here need to be set as well, but don't factor into quality, since
      % they don't affect the weapon's 'raw power'.
      piPrimaryStat = Nth(lstats,16);
      piSecondaryStat = Nth(lstats,17);
      piAttackType = Nth(lstats,18);
      piSpellType = Nth(lstats,19);
      piDeviation = Nth(lstats,20);
      
      if n <> 0
      {
         iQuality = iQuality / n;
      }


      % Set the quality
      piQuality = 100 + iQuality;

      % Scale durability with quality.
      piHits_init = bound(piHits_init * piQuality / 100,1,$);
      piHits = bound(piHits * piQuality / 100,1,$);

      propagate;
   }

   AppendDesc()
   {
      local i, target_type;

      if plObject_attributes <> $
      {
         for i in plObject_attributes
         {
            if IsClass(i,&WeaponSpellProc)
            {
               AppendTempString("\n\n");
               AppendTempString("Upon a successful strike, the runes engraved on this "); 
               AppendTempString(Send(self,@GetName));
               AppendTempString(" will cast ");
               AppendTempString(Send(Send(i,@GetSpell),@GetName));
               AppendTempString(" ");

               target_type = Send(i,@GetType);
               if target_type = 1
               {
                  AppendTempString("on you ");
               }
               if target_type = 2
               {
                  AppendTempString("on the enemy ");
               }

               AppendTempString("with ");
               AppendTempString(Send(i,@GetSpellPower));
               AppendTempString(" spellpower ");
               AppendTempString(Send(i,@GetProcChance));
               AppendTempString("\% of the time.");
            }
         }
      }

      propagate;
   }
   
   GetAttackName()
   {
      return vrName;
   }

   GetDamage(who=$,what=$)
   {
      local i, oWeapAtt, iBonus;

      iBonus = 0;
      
      for i in plItem_Attributes
      {
         oWeapAtt = Send(SYS,@FindItemAttByNum,#num=Send(self,@GetNumFromCompound,#compound=First(i)));
         if IsClass(oWeapAtt,&WeaponAttribute)
         {
            iBonus = iBonus + Send(oWeapAtt,@ModifyDamage,#who=poOwner,#what=what,#lData=i);
         }
      }
      
      return piDamage + iBonus;
   }

   GetProficiencyBonus(who=$,what=$)
   {
      return piProficiencyBonus;
   }

   GetHitMod(who=$,what=$,stroke_obj=$)
   {
      local i, oWeapAtt, iBonus;
      
      iBonus = 0;
      
      for i in plItem_Attributes
      {
         oWeapAtt = Send(SYS,@FindItemAttByNum,#num=Send(self,@GetNumFromCompound,#compound=First(i)));
         if IsClass(oWeapAtt,&WeaponAttribute)
         {
            iBonus = iBonus + Send(oWeapAtt,@GetHitMod,#who=poOwner,#what=what,#lData=i);
         }
      }
      return piHitMod + iBonus;
   }

   GetPrimaryScaling()
   {
      return piPrimaryScaling;
   }

   GetSecondaryScaling()
   {
      return piSecondaryScaling;
   }

   % This is called by the stroke to retrieve the relevant modifier.
   GetStrokeMod(Skill_num=0)
   {
      if Skill_num = SKID_STAB {  return piStab; }
      if Skill_num = SKID_STRIKE {  return piStrike; }
      if Skill_num = SKID_SLASH {  return piSlash; }
      if Skill_num = SKID_THRUST {  return piThrust; }
      if Skill_num = SKID_FIRE {  return piFire; }
      if Skill_num = SKID_TOUCH {  return piTouch; }
      
      return 100;
   }

   GetDisarmMod()
   {
      return piDisarmMod;
   }

   GetParryMod()
   {
      return piParryMod;
   }

   GetRange()
   {
      return piRange;
   }

   GetPrimaryStat()
   {
      return piPrimaryStat;
   }

   GetSecondaryStat()
   {
      return piSecondaryStat;
   }

   GetAttackType()
   {
      return piAttackType;
   }

   GetSpellType()
   {
      return piSpellType;
   }

   GetDeviation()
   {
      return piDeviation;
   }

   GetProfNum()
   {
      return viProficiency_needed;
   }

   GetStrokeNum(squareddistance=0)
   {
      if IsClass(self,&MartialWeapon)
      {
         return SKID_PUNCH;
      }

      if IsClass(self,&MagicWeapon)
      {
         return SKID_TOUCH;
      }

      if IsClass(self,&RangedWeapon)
      {
         return SKID_FIRE;
      }

      if squareddistance < 9216
      {
         if piStrike > piStab
         {
            return SKID_STRIKE;
         }
         else
         {
            return SKID_STAB;         
         }
      }

      if squareddistance < 25600
      {
         return SKID_SLASH;
      }

      return SKID_THRUST;
   }

   ImproveProficiency(who=$,target=$,bonus=0)
   {
      Send(Send(SYS,@findSkillbynum,#num=viProficiency_needed),@ImproveAbility,
            #who=who,#target=target,#bonus=bonus);

      return;
   }

   
   %%% Attack Type Functions (Enchanted weapons, Qor weapons, burning blades, etc.)

   SetAttackType(flag=0, value=FALSE)
   {
      if value
      {
         piAttackType = piAttackType | flag;
      }
      else
      {
         piAttackType = piAttackType & ~flag;
      }

      return;
   }

   CheckAttackType(flag=0)
   {
      return piAttackType & flag;
   }

   SetSpellType(flag=0, value=FALSE)
   {
      if value
      {
         piSpellType = piSpellType | flag;
      }
      else
      {
         piSpellType = piSpellType & ~flag;
      }

      return;
   }

   CheckSpellType(flag=0)
   {
      return piSpellType & flag;
   }

   % Weapons may do extra swings, usually depending on their secondary rating.
   GetSwings(who=$)
   {
      return 1;
   }

   %%%  Infrastructure

   ReqUseSomething(what=$)
   {
      if IsClass(what,&Weapon)
         OR IsClass(what,&Lute)
         OR IsClass(what,&JewelofFroz)
      {
         if Send(poOwner,@TryUnuseItem,#what=self)
         {
            propagate;
         }
         else
         {
            return FALSE;
         }
      }

      propagate;
   }

   DamageGear()
   {
      % 75% chance to be damaged, currently.
      if random(1,100) < WEAPON_TAKE_DAMAGE_PCT
      {
         piHits = piHits - 1;
      }

      if piHits <= 0
      {
         Send(self,@WeaponBroke);
      }

      return;
   }

   IsWeaponIntact()
   {
      if piHits <= 0
      {
         Send(poOwner,@MsgSendUser,#message_rsc=weapon_already_broken,
               #parm1=Send(self,@GetCapDef),#parm2=vrName);
         Send(poOwner,@TryUnuseItem,#what=self);

         return FALSE;
      }

      return TRUE;
   }

   ReqUseAmmo(ammotype=$)
   "At this point, a non-ranged weapon SHOULD never make it this far. "
   "This is just to catch anything that slips thru the cracks."
   "See ranged.kod for what this does."
   {
      Debug("A non-ranged weapon called @ReqUseAmmo!");

      return TRUE;
   }

   WeaponBroke()
   {
      local i, oItemAtt;

      % Remove itematts from us, since we're not gonna use 'em anymore.
      % This also lets cursed items finally remove themselves from us.
      for i in plItem_Attributes
      {
         oItemAtt = Send(SYS,@FindItemAttByNum,
                         #num=Send(self,@GetNumFromCompound,#compound=First(i)));
         Send(oItemAtt,@RemoveFromItem,#oItem=self);
      }

      Send(poOwner,@SomethingChanged,#what=self);
      Send(poOwner,@MsgSendUser,#message_rsc=vrWeaponBroke,
            #parm1=Send(self,@GetCapDef),#parm2=vrName);
      Send(poOwner,@TryUnuseItem,#what=self);

      return;
   }

   WeaponAttack()
   "Called by DoSwing in player when the weapon is actually used in an attack."
   {
      piUsed = ATTACKING;
      
      if vrWeapon_window_overlay <> $
      {
         Send(poOwner,@ChangeWindowOverlay,#what=self);
      }

      if vrWeapon_overlay <> $
      {
         Send(poOwner,@DoAttackSwing);
      }

      piUsed = USED;

      return;
   }

   NewUsed()
   {
      local oItemAtt;

      % This alerts Item attributes when item is used.
      % Currently special checks for "glowing" weapon attribute.
      if Send(self,@HasAttribute,#ItemAtt=WA_GLOWING)
      {
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=WA_GLOWING);
         Send(oItemAtt,@ItemUsed,#oItem=self,#oPlayer=poOwner);
      }

      piUsed = USED;

      % Do first person overlay if we have one
      if vrWeapon_window_overlay <> $
      {
         Send(poOwner,@SetWindowOverlay,#what=self);
      }

      % Do third person overlay if we have one
      if vrWeapon_overlay <> $
      {
         Send(poOwner,@SetOverlay,#what=self);
      }

      Send(self,@ActivateCombatMods);

      propagate;
   }

   NewUnused()
   {
      local oItemAtt;

      % This alerts Item attributes when item is used.
      % Currently special checks for "glowing" weapon attribute.
      if Send(self,@HasAttribute,#ItemAtt=WA_GLOWING)
      {
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=WA_GLOWING);
         Send(oItemAtt,@ItemUnused,#oItem=self,#oPlayer=poOwner);
      }

      piUsed = UNUSED;

      if vrWeapon_window_overlay <> $
      {
         Send(poOwner,@RemoveWindowOverlay,#what=self);
      }

      if vrWeapon_overlay <> $
      {
         Send(poOwner,@RemoveOverlay,#what=self);
      }

      Send(self,@DeactivateCombatMods);

      propagate;
   }

   ActivateCombatMods()
   {
      Send(poOwner,@AddSpellpowerMod,#amount=piSpellpowerMod);

      return;
   }

   DeactivateCombatMods()
   {
      Send(poOwner,@AddSpellpowerMod,#amount=-piSpellpowerMod);

      return;
   }

   % Weapons may have a special on hit effect that scales with the weapon's
   % secondary stat. This effect may vary depending on the wielder, the target
   % and the stroke. For example, bows may use arrows that can shatter on
   % impact or do extra damage to undead targets. Swords may deal extra damage
   % from behind or be especially lethal against murderers.
   DoSpecialEffect(who=$,what=$,stroke_obj=$,power=0)
   {
      return 0;
   }

   %%% Animation Functions

   % these 5 called by player, for window overlays.
   % weapon subclasses--do NOT set a window overlay unless you either
   % set vrWeapon_window_overlay correctly or override all these message handlers
   GetWindowOverlay()
   {
      return vrWeapon_window_overlay;
   }

   GetWindowOverlayID()
   {
      return PWO_RIGHT_HAND;
   }

   GetWindowOverlayHotspot()
   {
      if piUsed = UNUSED
      {
         % turns off the window overlay
         return 0;
      }

      return HS_SE;
   }

   SendWindowOverlayAnimation()
   {
      local iFlags;

      iFlags = piItem_flags & ITEM_PALETTE_MASK;
      if iFlags <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,iFlags);
      }

      if piUsed = ATTACKING
      {
         AddPacket(1,ANIMATE_ONCE, 4,150, 2,vrWeapon_window_attack_start,
                   2,vrWeapon_window_attack_end, 2,vrWeapon_window_hold);
      }
      else
      {
         AddPacket(1,ANIMATE_NONE, 2,vrWeapon_window_hold);
      }

      return;
   }

   SendWindowOverlayOverlays()
   {
      % no overlays
      AddPacket(1,0);

      return;
   }

   % These 3 called by player, for normal 3rd-person overlays on user.
   % weapon subclasses--do NOT set a window overlay unless you either
   % set vrWeapon_overlay correctly or override all these message handlers

   GetOverlay(animation=$)
   {
      return vrWeapon_overlay;
   }

   GetOverlayHotspot(animation=$)
   {
      return HS_RIGHT_WEAPON;
   }

   SendOverlayAnimation(iAnimation=$)
   {
      local iFlags;

      iFlags = piItem_flags & ITEM_PALETTE_MASK;
      if iFlags <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,iFlags);
      }

      if iAnimation = PANM_WEAPON_ATTACK 
      {
         AddPacket(1,ANIMATE_ONCE, 4,300, 2,1, 2,3, 2,4);
      }
      else
      {
         AddPacket(1,ANIMATE_NONE, 2,4);
      }

      return;
   }

   SendOverlayInformation(ianimation=$)
   {
      AddPacket(4,Send(self,@GetOverlay));
      AddPacket(1,Send(self,@GetOverlayHotspot));
      Send(self,@SendOverlayAnimation,#iAnimation=iAnimation);

      return;
   }

   SendInventoryAnimation()
   {
      local iFlags;

      if piHits > 0 OR viBroken_group = $
      {
         propagate;
      }

      iFlags = piItem_flags & ITEM_PALETTE_MASK;
      if iFlags <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,iFlags);
      }

      AddPacket(1,ANIMATE_NONE, 2,viBroken_group);

      return;
   }

   SendLookAnimation()
   {
      local iFlags;

      if piHits > 0 OR viBroken_group = $
      {
         propagate;
      }

      if (piItem_flags & ITEM_PALETTE_MASK) <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION,1,piItem_flags & ITEM_PALETTE_MASK);
      }

      AddPacket(1,ANIMATE_NONE,2,viBroken_group);

      return;
   }

   SendAnimation()
   {
      local iFlags;

      if piHits > 0 OR viBroken_group = $
      {
         propagate;
      }

      iFlags = piItem_flags & ITEM_PALETTE_MASK;
      if iFlags <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,iFlags);
      }

      AddPacket(1,ANIMATE_NONE, 2,viBroken_group);

      return;
   }

   %%% Permission Functions

   CanMend()
   "Weapons are mendable, usually."
   {
      local i, oItemAtt;

      for i in plItem_Attributes
      {
         oItemAtt = Send(SYS,@FindItemAttByNum,
                         #num=Send(self,@GetNumFromCompound,#compound=First(i)));
         if oItemAtt = $
         {
            Debug("Illegal ItemAtt in list!");

            continue;
         }

         if NOT Send(oItemAtt,@ItemCanMend,#oItem=self)
         {
            return FALSE;
         }
      }

      return TRUE;
   }

   ValidateWeaponAttributes(num = 1)
   "Deletes any items with more major weapon attributes than num. Default 1."
   {
      local iNum;

      iNum = 0;

      if plItem_attributes = $
      {
         return;
      }

      if Send(self,@HasAttribute,#itematt=WA_BLINDER)
      {
         iNum = iNum + 1;
      }

      if Send(self,@HasAttribute,#itematt=WA_PARALYZER)
      {
         iNum = iNum + 1;
      }

      if Send(self,@HasAttribute,#itematt=WA_VAMPER)
      {
         iNum = iNum + 1;
      }

      if Send(self,@HasAttribute,#itematt=WA_PURGER)
      {
         iNum = iNum + 1;
      }

      if iNum > num
      {
         Post(self,@Delete);
         Debug("Multiple attribute weapon deleted.");
      }

      return;
   }

   CanEnchant(oSpell = $)
   "Weapons CAN usually be dedicated to Qor, Kraanan or Shal'ille.  "
   "Exception:  weapons that are already enchanted may not be, "
   "but this is taken care of on a spell by spell basis, so that reagents "
   "are used correctly."
   {
      local i, oItemAtt, iSpell;

      if piSpellType <> 0
         OR Send(self,@CheckAttackType,#flag=ATCK_WEAP_MAGIC)
      {
         iSpell = Send(oSpell,@GetSpellNum);
         if iSpell = SID_HOLY_WEAPON or iSpell = SID_UNHOLY_WEAPON
            OR iSpell = SID_ENCHANT_WEAPON
         {
            return TRUE;
         }
      }

      for i in plItem_Attributes
      {
         oItemAtt = Send(SYS,@FindItemAttByNum,
                         #num=Send(self,@GetNumFromCompound,#compound=First(i)));
         if oItemAtt = $
         {
            Debug("Illegal ItemAtt in list!");

            continue;
         }

         if NOT Send(oItemAtt,@ItemCanEnchant,#oItem=self)
         {
            return FALSE;
         }
      }

      return TRUE;
   }

   ReqRepair()
   {
      return TRUE;
   }

   CanBeDisarmed()
   {
      return TRUE;
   }

   %%%Description Related Messages %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

   GetSpellpowerMod()
   {
      return piSpellpowerMod;
   }

   GetQuality()
   {
      return piQuality;
   }

end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
